//#include<stdio.h>
//#include<malloc.h>

//typedef struct treeNode {
//	char data;
//	struct treeNode* left;
//	struct treeNode* right;
//} treeNode;

// 이진 트리의 순회 
// 계층적 구조로 저장되어있는 트리의 모든 노드를 방문하여 데이터를 처리하는 연산
// 3가지로 전위순회, 중위순회, 후위순회가 있는데
// 전위순회는 자손노드보다 루트노드를 먼저 방문한다
// A(root) -> B(왼쪽) -> C(오른쪽)

// 중위순회 왼쪽 자손, 루트, 오른쪽 자손 순으로 방문한다
// B(왼쪽) -> A(root) -> C(오른쪽)

// 후위순회 루트노드보다 자손을 먼저 방문한다
// B(왼쪽) -> C(오른쪽) -> A(root)

// 크게 잡는 방법에 대해서는 그림을 참조

// x(KEY) = rootNode의 KEY 값 -> 원하는 원소 찾았으므로 탐색연산에 성공
// x(KEY) < rootNode의 KEY 값 -> rootNode의 왼쪽 subTree에 대해 탐색연산
// x(KEY) > rootNode의 KEY 값 -> rootNode의 오른쪽 subTree에 대해 탐색연산


// 이진트리의 삽입이란 이진트리에 대한 탐색을 진행하였을때 끝내 값을 찾지 못하면 마치막 탐색실패한 위치에 노드값을 삽입하는 것

// 삭제도 그냥 삭제가 아니다. 노드가 단말 노드인경우와 자식노드를 가진경우로 나뉜다.

// 단일 노드인경우 그냥 삭제
// 치수가 1 그러니까 8 -> 10 -> 14 (자식노드 2개) 인경우
// 10이 삭제되면 10의 자리를 14가 물려받음
// 차수가 2인경우 
// 방법이 2가지가 있는데
// 1. 왼쪽 서브트리에서 가장 큰 자손노드 선택 
// 왼쪽 서브트리의 오른쪽 링크를 따라 계속 이동하여 오른쪽 링크 필드가 NULL인 노드 즉, 가장 오른쪽에 있는 노드가 후계자가 된다.

// 2. 오른쪽 서브트리에서 가장 작은 자손노드 선택 
// 오른쪽 서브트리에서 왼쪽 링크를 따라 계속 이동하여 왼쪽 링크 필드가 NULL인 노드 즉, 가장 왼쪽에 있는 노드가 후계자가 된다.

//결론적으로 차수2를 처리하는 경우
// 1단계 : 노드 삭제
// 2단계 : 삭제한 노드의 자리를 후계자에게 물려주기
// 3단계 : 후계자노드의 원래자리를 자식노드에게 물려주기